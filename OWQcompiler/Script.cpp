/* 
 * File:   Script.h
 * Author: shlomo hassid
 *
 */
#include "Script.h"
#include "Parser.h"

#include <math.h>
#include <fstream>
#include <streambuf>

namespace fs = boost::filesystem;

Script::Script() {
    code.reserve(300);	//pre-allocate 100 instruction space for byte-codes
    functions.reserve(50);	//pre allocate 50 spaces for functions
    internalStaticPointer = 0;
	script_debug = OWQ_DEBUG;
}

void Script::addInstruction(Instruction I) {
    addInstruction(I, false);
}
void Script::addInstruction(Instruction I, bool allowRST) {
    //reject instructions with RST operands
    if (!allowRST && I.getOperand() == "RST") {
        return;
    }
    code.push_back(I);
    if (I.getCode() ==  ByteCode::FUNC) {
        functionTable[I.getOperand()] = getSize()-1;
    }
}

/**
 *
 * Returns the address/index of the function requested by funcName
 * @param funcName
 * @return
 */
int Script::getFunctionAddress(std::string funcName){
	std::map<std::string, int>::iterator it = functionTable.find(funcName);
    if (it != functionTable.end()) {
        return it->second;
    } else {
        return -1;
    }
}

/** A DEBUGGER Function
 *  Display the script byte code
 * 
 */
void Script::render() {
    if (OWQ_DEBUG_EXPOSE_FUNCTION_TABLE && OWQ_DEBUG_LEVEL > 1) {
        Lang::printHeader("Function Tables");
        for(std::map<std::string, int>::const_iterator it = functionTable.begin(); it != functionTable.end(); ++it) {
			std::cout << " Key: " << it->first << ", Value: " << it->second << std::endl;
        }
        Lang::printSepLine(2);
    }
    
    Lang::printHeader("Generated Byte Code");
    for (int i=0; i<(int)code.size(); i++) {
		std::cout << " " << i << "\t" << code[i].toString() ;
        if(code.size()-1 == i) {
			std::cout << " <---- Injection point" << std::endl;
        } else {
			std::cout << std::endl;
        }
    }
}

int Script::getSize() {
    return code.size();
}

void Script::execute(std::string funcCallExp) {
    // Parser used to compile the expressing inside of funcCallExp
    Parser p;
    // holds the compiled set of instructions to successfully call the function(s) within this->code
    Script callScript;
    // generate the set of instructions represented in funcCallExp
    p.compile(&callScript, funcCallExp);
    int ip = this->getSize(); //points to end of instruction(getSize()-1) + 1
                              //effectively ip is the size of the script
                              //so when callScript is injected it points this script
                              //ip points perfectly to the instruction of where to
                              //start executing to properly use the script
    int orip = ip; //the original ip, save a copy, used for removing the injected code
    int injectionSize = injectScript(&callScript); //number of instructions injected, used for injection removal

    //-----------------------------------------------------------
    //Run the code												|
    //	start at instruction address ip							|
    //	terminates when executeInstruction method returns 0		|
    //-----------------------------------------------------------
    for (; ip < getSize(); ip++) {
        if ( executeInstruction(code[ip],ip)  == 0 ) {
            break; //execution is done when executeInstruction returns 0-->secondary to RET opcode
        }
    }
    //-----------------------------------------------------------
    //erase/release the amount of injection that was made earlier		|
    //-----------------------------------------------------------
    for(int i=0; i<injectionSize; i++){
        code.erase(code.begin()+orip);
    }
    
    //Stack::render();
}

void Script::run() {
    run(false);
}
void Script::run(bool debug) {
    if ( debug && OWQ_DEBUG_EXPOSE_EXECUTION_STEPS && OWQ_DEBUG_LEVEL > 1) {
        Lang::printHeader("Chunk Execution steps");
    }
    for (int ip = 0; ip < getSize(); ip++) {
        if ( executeInstruction(code[ip], ip, debug)  == 0 ) {
            break; //execution is done when executeInstruction returns 0-->secondary to RET opcode
        }
    }
}

/**
 *
 * executeInstruction is the workhorse of the script calls.
 *
 * It functions as the Virtual Machine/ CPU.  As such, it performs
 * all the calculations, operations needed of it
 * @param code
 * @param instructionPointer
 * @param boolean debug DEFAULT : FALSE
 * @return integer
 */
int Script::executeInstruction(Instruction xcode, int& instructionPointer) {
    return executeInstruction(xcode, instructionPointer, false);
}
int Script::executeInstruction(Instruction xcode, int& instructionPointer, bool debug) {
    
    //Some debugging:
    if ( debug && OWQ_DEBUG_EXPOSE_EXECUTION_STEPS && OWQ_DEBUG_LEVEL > 1) {
        if (OWQ_DEBUG_EXPOSE_EXECUTIOM_STACK_STATE && OWQ_DEBUG_LEVEL > 2) {
            Stack::render();
        }
		std::cout << std::endl << " * Executing(" << xcode.getCode() << ") " << xcode.toString() << std::endl;
    }

    //------------------------------------------
    //
    //------------------------------------------
    int ret = 1;	//1 = continue, 0 = terminate execution
    switch (xcode.getCode()) {
        case ByteCode::NOP:
            break;
        case ByteCode::SWA:
            Stack::Swap();
            break;
        case ByteCode::SHT:
            Stack::ShiftTop(true);
            break;
        case ByteCode::PUSH:
			if (xcode.isOperandString()) { //if operand is string
				if (xcode.operandHasQuote()) {          //if this operand is in the form---> ["what is this a string literal"]
					Stack::push(xcode.getOperand());	//save the string literal
				} else if (xcode.isRstPointer() && xcode.getPointer() > 0) { // We are handling with a static stack pointer
					Stack::push(StackData(true, xcode.getPointer())); //This will push the special type of RST
				} else if (xcode.isOperandBoolean()) {
					Stack::push(StackData(xcode.getOperand(), true)); //This will push a boolean stack data
				} else {
                    //the operand is in a form --> someWord <<---------no quotes around it, meaning it is a name of variable
                    //find that variable from the function/method stacking
                    ScriptVariable* sv = getVariable(xcode.getOperand());
                    //complain if variable is not found
                    if (sv == NULL) {
                        ScriptError::msg("unable to resolve variable name: " + xcode.getOperand());
                    } else {
                        //else push the value
                        Stack::push(*sv);
                    }
                }
            } else {
                Stack::push(xcode.getNumber());
            }
            //if operand is a reference to some variable, push its value onto the stack
			if (xcode.getPointer() > 0) {
				Stack::setTopPointer(xcode.getPointer());
			}
            break;
        case ByteCode::RET:{
                Method *m = getActiveMethod();	//get active method
                if (m != NULL) {
                    instructionPointer = m->getReturnAddress() - 1 ;	//minus one because execution loop automatically increase by 1
                    //if functions stack size == 1, then we are at the end of the execution stack,
                    //meaning that we we can stop executing the script
                    if (functions.size() == 1) {
                        ret = 0;
                    }
                } else {
                    ScriptError::msg("instruction for return without active method");
                }
                //return pops the method/function off the method stack
                popActiveMethod();
            }
            break;
        case ByteCode::ASN:{
                StackData sd = Stack::pop();		//pop and get the value to assign
                ScriptVariable* sv = getVariable(xcode.getOperand());	//get the variable we wish to sign to
                if (sv == NULL) {
                    ScriptError::msg("unable to resolve symbol " + xcode.getOperand());
                } else {
                    //assign the value
					if (!sv->setValue(sd)) {
						ScriptError::msg("unable to assign to native variable");
					}
                }
            }
            break;
        case ByteCode::GTR: {
                StackData b = Stack::pop();
                StackData a = Stack::pop();
                if (a.isNumber(true) && b.isNumber(true)) {                           //a = number AND b = number
                    Stack::push(StackData(a.getNumber(true) > b.getNumber(true)));
                } else if (a.isNumber(true) && b.isString()) {                  //a = number AND b = string
                    Stack::push(StackData(a.getNumber(true) > b.getString().length()));
                } else if (a.isString() && b.isNumber(true)) {                  //a = string AND b = number
                    Stack::push(StackData(a.getString().length() > b.getNumber(true)));
                } else if (a.isString() && b.isString()) {                  //a = string AND b = string
                    Stack::push(StackData(a.getString().length() > b.getString().length()));
                } else {
                    ScriptError::msg("Tried To GTR with unsupported types");
                    Stack::push(StackData(false));
                }
                if (xcode.getPointer() > 0) {
                    Stack::setTopPointer(xcode.getPointer());
                }
            }
            break;
        case ByteCode::LSR:{
                StackData b = Stack::pop();
                StackData a = Stack::pop();
                if(a.isNumber(true) && b.isNumber(true)) {                                   //a = number AND b = number
                    Stack::push(StackData(a.getNumber(true) < b.getNumber(true)));
                } else if(a.isNumber(true) && b.isString()) {                            //a = number AND b = string
                    Stack::push(StackData(a.getNumber(true) < b.getString().length()));
                } else if(a.isString() && b.isNumber(true)) {                            //a = string AND b = number
                    Stack::push(StackData(a.getString().length() < b.getNumber(true)));
                } else if (a.isString() && b.isString()) {                           //a = string AND b = string
                    Stack::push(StackData(a.getString().length() < b.getString().length()));
                } else {
                    ScriptError::msg("Tried To LSR with unsupported types");
                    Stack::push(StackData(false));
                }
                if (xcode.getPointer() > 0) {
                    Stack::setTopPointer(xcode.getPointer());
                }
                
            } 
            break;
        case ByteCode::CVE:{
                StackData b = Stack::pop();
                StackData a = Stack::pop();
                if(a.isNumber(true) && b.isNumber(true)) {                                    //a = number AND b = number
                    Stack::push(StackData(a.getNumber(true) == b.getNumber(true)));
                } else if (a.isNumber(true) && b.isString()) {                            //a = string AND b = string
                    Stack::push(StackData(a.getNumber(true) == b.getString().length()));
                } else if (a.isString() && b.isNumber(true)) {                            //a = string AND b = number
                    Stack::push(StackData(a.getString().length() == b.getNumber(true)));
                } else if (a.isString() && b.isString()){                             //a = string AND b = string
                    Stack::push(StackData(a.getString() == b.getString()));
                } else {
                    Stack::push(StackData(false));
                }
				if (xcode.getPointer() > 0) {
					Stack::setTopPointer(xcode.getPointer());
				}
            }
            break;
        case ByteCode::LOOP:	
            //just acts as a marker
            break;
        case ByteCode::DONE:	
            //I call the instruction "DONE" a --repeater because it functions to change the instruction pointer to the first                    
            //imediate LOOP instruction by stepping backwards from the current code address
            //when at done, step backwards to first occurance of LOOP
            if(xcode.getOperand() == Lang::LangFindKeyword("loop-while")){
                for(int j=instructionPointer; j > -1; j--){	//step backwards
                    if(code[j].getCode() == ByteCode::LOOP){			//if the instruction has an instruction code that matches LOOP
                        instructionPointer = j;				//set that instruction address to ip and break immediately
                        break;
                    }
                }
            } else if (xcode.getOperand() == Lang::LangFindKeyword("cond-if")) {
                //do nothing
            } else if (xcode.getOperand() == Lang::LangFindKeyword("cond-else")) {
                //do nothing
            } else {
                //do nothing
            }
            break;
        case ByteCode::EIF:	//end of function
            break;
        case ByteCode::AND:{
                StackData b = Stack::pop();
                StackData a = Stack::pop();
                if (!a.isNumber(true) || !b.isNumber(true)) {  
                    ScriptError::msg("expected evaluation of boolean expression to be numeric"); 
                } else if(a.getNumber(true) > 0 && b.getNumber(true) > 0) { 
                    Stack::push(StackData(true));
                } else {  
                    Stack::push(StackData(false));
                }
				if (xcode.getPointer() > 0) {
					Stack::setTopPointer(xcode.getPointer());
				}
            }
            break;
        case ByteCode::POR:{
                StackData b = Stack::pop();
                StackData a = Stack::pop();
                if (!a.isNumber(true) || !b.isNumber(true)) {  
                    ScriptError::msg("expected evaluation of boolean expression to be numeric"); 
                } else if ( a.getNumber(true) > 0 || b.getNumber(true) > 0 ) { 
                    Stack::push(StackData(true));
                } else {  
                    Stack::push(StackData(false));
                }
				if (xcode.getPointer() > 0) {
					Stack::setTopPointer(xcode.getPointer());
				}
            }
            break;
		case ByteCode::BRE: {
			StackData a = Stack::pop();
			if (!a.isNumber() || a.getNumber() < 1) {
				ScriptError::msg("break expected positive numeric value - skipped loop break");
			} else {
				int nestedLoops = 0;
				int numberOfBreaks = (int)a.getNumber();
				int j = instructionPointer + 1;
				for (j; j < (int)code.size(); j++) {	//scan for next Done
					ByteCode curBC = code[j].getCode();
					std::string cupOPr = code[j].getOperand();
					std::string langIf = Lang::LangFindKeyword("cond-if");
					std::string langElse = Lang::LangFindKeyword("cond-else");
					if (curBC == ByteCode::CMP || curBC == ByteCode::ELE) { //if the instruction has an instruction code that matches LOOP OR IF BLOCKS AFTER the BLOCK avoid
						nestedLoops++;
					} else if (nestedLoops > 0 && curBC == ByteCode::DONE) {
						nestedLoops--;
					} else if (
						nestedLoops == 0 
						&& curBC == ByteCode::DONE
						&& cupOPr != langIf
						&& cupOPr != langElse
					) {
						numberOfBreaks--;
					}
					if (numberOfBreaks == 0) {
						break;
					}
				}
				if (numberOfBreaks == 0) {
					instructionPointer = j;
				}
				else {
					ScriptError::msg("wrong break number used!");
					ret = 0;
				}
			}
		}
		break;
		case ByteCode::BIF: {
			StackData a = Stack::pop();
			if (!a.isNumber() || a.getNumber() < 1) {
				ScriptError::msg("break expected positive numeric value - skipped condition break");
			} else {
				int nestedConds = 0;
				int numberOfBreaks = (int)a.getNumber();
				int j = instructionPointer + 1;
				for (j; j < (int)code.size(); j++) {	//scan for next Done
					ByteCode curBC = code[j].getCode();
					std::string cupOpr = code[j].getOperand();
					std::string langWhile = Lang::LangFindKeyword("loop-while");
					if (curBC == ByteCode::CMP || curBC == ByteCode::ELE) { //if the instruction has an instruction code that matches LOOP OR IF BLOCKS AFTER the BLOCK avoid
						nestedConds++;
					}
					else if (nestedConds > 0 && curBC == ByteCode::DONE) {
						nestedConds--;
					} else if (
						nestedConds == 0
						&& curBC == ByteCode::DONE
						&& cupOpr != langWhile
						) {
						numberOfBreaks--;
					}
					if (numberOfBreaks == 0) {
						break;
					}
				}
				if (numberOfBreaks == 0) {
					instructionPointer = j;
				}
				else {
					ScriptError::msg("wrong break number used!");
					ret = 0;
				}
			}
		}
		break;
        case ByteCode::CMP:{	
                //I call CMP as the gate keeper because it functions to determine if the body of a condition can be executed or
                //not depending of the value on the stack
                StackData a = Stack::pop();	//used to overal condition of the while or if statement
                //1 - true : 0 - false OR boolean type
                if (!a.isNumber(true)) 
				{ 
                    ScriptError::msg("expected evaluation of boolean expression to be numeric"); 
                } else {
                    if (a.getNumber(true) > 0) { //condition is true
                        //continue
                    } else {
                        int matchCount = 0;
						std::string curCode = code[instructionPointer].getOperand();
                        //used to match respective cmp and done so we enter or exit the right conditon bodies
                        //-----------------------------------------------------------------------------------------------------|
                        //condition is false																				   |
                        //search for the next immediate "DONE" instruction, because it marks the end of the loop & escape	   |
                        //-----------------------------------------------------------------------------------------------------|
                        for (int j = instructionPointer; j < this->getSize(); j++) {
                            if (code[j].getCode() == ByteCode::CMP && code[j].getOperand() == curCode) {
                                ++matchCount;
                            }
                            if (code[j].getCode() == ByteCode::DONE && code[j].getOperand() == curCode) {
                                --matchCount;
                            }
                            if (matchCount == 0) {
                                    instructionPointer = j;	//change instruction pointer to be at this instancce of done instruction
                                    break;	//stop
                            } //end match case
                        }//end for loop
                        //Check if there is a else statement:
                        if (curCode == Lang::LangFindKeyword("cond-if") && instructionPointer + 1 < (int)code.size()) {
                            if (code[instructionPointer + 1].getCode() == ByteCode::ELE) {
                                //Jump to after target else
                                instructionPointer++;
                            }
                        }
                    }//end else
                }//end else not number
            }
            break;
        case ByteCode::ELE: {
                 //jump the block cause the only way is through the IF and not directly:
                int matchCount = 0;
                for (int j = instructionPointer; j < this->getSize(); j++) {
                    if (code[j].getCode() == ByteCode::ELE) {
                        ++matchCount;
                    }
                    if (code[j].getCode() == ByteCode::DONE && code[j].getOperand() == Lang::LangFindKeyword("cond-else")) {
                        --matchCount;
                    }
                    if (matchCount == 0) {
                        instructionPointer = j; //change instruction pointer to be at this instancce of done instruction
                        break; //stop
                    } //end match case
                }//end for loop
            }
            break;
        case ByteCode::ADD:{
                StackData b = Stack::pop();
                StackData a = Stack::pop();
                if (a.isNumber(true) && b.isNumber(true)) {                         //a = number AND b = number
                    Stack::push(a.getNumber(true) + b.getNumber(true));
                } else if (a.isNumber(true) && b.isString()) {                  //a = number AND b = string
                    Stack::push(a.numberValueToString(true) + b.getString());
                } else if (a.isString() && b.isNumber(true)) {                  //a = string AND b = number
                    Stack::push(a.getString() + b.numberValueToString(true));
                } else if (a.isString() && b.isString()) {                                                    //a = string AND b = string
                    Stack::push(a.getString() + b.getString());
                } else { //Unsupprted.
                    ScriptError::msg("Tried To ADD with unsupported types");
                    Stack::push(0);
                }
                if (xcode.getPointer() > 0) {
                    Stack::setTopPointer(xcode.getPointer());
                }
            }
            break;
        case ByteCode::SUB: {
                StackData b = Stack::pop();
                StackData a = Stack::pop();
                if (a.isNumber(true) && b.isNumber(true)) {                     //a = number AND b = number
                    Stack::push(a.getNumber(true) - b.getNumber(true));
                } else if (a.isNumber(true) && b.isString()) {             //a = number AND b = string
                        Stack::push(a.getNumber(true) - b.getString().length());
                } else if (a.isString() && b.isNumber(true)) {             //a = string AND b = number
                        Stack::push(a.getString().length() - b.getNumber(true));
                } else if (a.isString() && b.isString()){                                                //a = string AND b = string
                        Stack::push(a.getString().length() - b.getString().length());
                } else { //Unsupprted.
                    ScriptError::msg("Tried To SUB with unsupported types");
                    Stack::push(0);
                }
                if (xcode.getPointer() > 0) {
                    Stack::setTopPointer(xcode.getPointer());
                }
            }
            break;
        case ByteCode::MULT:{
                StackData b = Stack::pop();
                StackData a = Stack::pop();
                if (a.isNumber(true) && b.isNumber(true)) {  //a = number AND b = number
                    Stack::push(a.getNumber(true) * b.getNumber(true));
                } else if(a.isNumber(true) && b.isString()) {  //a = number AND b = string
                    Stack::push(a.getNumber(true) * b.getString().length());
                } else if(a.isString() && b.isNumber(true)) {  //a = string AND b = number
                    Stack::push(a.getString().length() * b.getNumber(true));
                } else if(a.isString() && b.isString()){  //a = string AND b = string
                    Stack::push(a.getString().length() * b.getString().length());
                } else { //Unsupprted.
                    ScriptError::msg("Tried To MULT with unsupported types");
                    Stack::push(0);
                }
                if (xcode.getPointer() > 0) {
                    Stack::setTopPointer(xcode.getPointer());
                }
            }
            break;
        case ByteCode::DIV:{
                StackData b = Stack::pop();
                StackData a = Stack::pop();
				if (b.isString()) {  //First make sure b is not of zero length string
					if (b.getString().length() == 0) {
						ScriptError::msg("division by zero prevented, calculation aborted");
						break;
					}
				}
                if (a.isNumber(true) && b.isNumber(true)) {  //a = number AND b = number
                    if (b.getNumber() == 0.0) {
                        ScriptError::msg("division by zero prevented, calculation aborted");
                        break;
                    }
                    Stack::push(a.getNumber(true) / b.getNumber(true));
                } else if (a.isNumber(true) && b.isString()) {  //a = number AND b = string
                        Stack::push(a.getNumber(true) / b.getString().length());
                } else if (a.isString() && b.isNumber(true)) {  //a = string AND b = number
                        Stack::push(a.getString().length() / b.getNumber(true));
                } else if (a.isString() && b.isString()) {   //a = string AND b = string
                        Stack::push(a.getString().length() / b.getString().length());
				} else { //Unsupprted.
					ScriptError::msg("Tried To DIV with unsupported types");
					Stack::push(0);
				}
                if (xcode.getPointer() > 0) {
                    Stack::setTopPointer(xcode.getPointer());
                }
            }
			break;
        case ByteCode::EXPON:{
                StackData b = Stack::pop();
                StackData a = Stack::pop();
                if (a.isNumber(true) && b.isNumber(true)){  //a = number AND b = number
                    Stack::push( pow(a.getNumber(true) , b.getNumber(true)));
                } else if(a.isNumber(true) && b.isString()) {  //a = number AND b = string
					Stack::push(pow(a.getNumber(true), b.getString().length()));
                } else if(a.isString() && b.isNumber(true)){  //a = string AND b = number
					Stack::push(pow(a.getString().length(), b.getNumber(true)));
                } else if (a.isString() && b.isString()) {  //a = string AND b = string                                               //a = string AND b = string
					Stack::push(pow(a.getString().length(), b.getString().length()));
				} else { //Unsupprted.
					ScriptError::msg("Tried To EXPON with unsupported types");
					Stack::push(0);
				}
                if (xcode.getPointer() > 0) {
                    Stack::setTopPointer(xcode.getPointer());
                }
            }
			break;
		case ByteCode::FUNC: {
				//save the return address inside the newly created executing function
				pushMethod(instructionPointer + 1, xcode.getOperand());
			}
			break;
        case ByteCode::ARG: {
                Method *m = getActiveMethod();
                if ( m == NULL ) {
                    ScriptError::msg("argument definition requires execution of method");
                } else {
                    StackData sd = Stack::pop();
					if (!m->addVariable(xcode.getOperand(), sd)) {
						ScriptError::msg("re-definition of variable in method");
					}
                }
            } 
			break;
		case ByteCode::ARGC: {
				if (xcode.getNumber() <= Stack::size()) {

				} else {
					ScriptError::msg("Current active method requires sufficient argument");
				}
			}
            break;
        case ByteCode::DEF:{
                Method *m = getActiveMethod();
                if (m == NULL) {
                    //Assign in global scope:
                    registerVariable(xcode.getOperand());
                } else {
                    //Assign in method scope:
                    m->addVariable(xcode.getOperand());
                }
            }
			break;
        case ByteCode::CALL:{ //begin of call switch
				std::string operand = xcode.getOperand();
				std::string object = "NULL";
				std::string method = operand;
                int dotOperator = operand.find_first_of(".");

                if(dotOperator != -1) {
                        object = operand.substr(0,dotOperator);
                        method = operand.substr(dotOperator+1);
                }
                if (isSystemCall(object, method, xcode)) {
                    break;
                } else {
                    int address = getFunctionAddress(operand);
                    if (address == -1) {
                        ScriptError::msg("unable to find method " + operand);
                    } else {
                        instructionPointer = address -1;
                    }
                    break;
                }
            }//end of call switch
    }
    return ret;
}

/**
 *
 * Push/Create a method and push it onto the stack
 *
 * This scheme helps to determine when to quit executing the script as a whole and return
 * control over to the main/non-scripted application.  Additionally, as pushMethod is call
 * the return address to which when this method is done executing will return to is passed
 *
 * @param retAddress
 */
void Script::pushMethod(int retAddress, std::string name) {
    functions.push_back(Method(retAddress, name));
}

/**
 *
 *
 * Remove the actively executing script method of the calling stack/method stack
 *
 *
 */
void Script::popActiveMethod() {
    if (functions.size() == 0) {
        ScriptError::msg("return from function requires stack popping, however method stack is empty");
        return;
    } else {
        functions.pop_back();
    }
}
/** Assign a global variable scope from Application layer 
 *  This means that a pointer address will be passed to the global.
 *  @param string name
 *  @param RegisteredVariable type will be a enum value
 *  @param void* address
 *  @return boolean
 */
bool Script::registerVariable(std::string name, RegisteredVariable type, void* address) {
	if (variables.find(name) == variables.end()) {
		variables[name] = ScriptVariable(name, type, address);
		return true;
	}
	return false;
}
bool Script::registerVariable(std::string name) {
    //Will register a global scope value but without a pointer address should
    //not be unregistered at the end of execution:
	if (variables.find(name) == variables.end()) {
		variables[name] = ScriptVariable(name);
		return true;
	}
	return false;
}
bool Script::registerVariable(std::string name, StackData& sd) {
	//Will register a global scope value but without a pointer address should
	//not be unregistered at the end of execution:
	if (variables.find(name) == variables.end()) {
		variables[name] = ScriptVariable(name, sd);
		return true;
	}
	return false;
}
/** Unregister a variable only if it exists:
 * @param string name
 * @return boolean
*/
bool Script::unregisterVariable(std::string name){
	std::map<std::string, ScriptVariable>::iterator it;
    it = variables.find(name);
    if (it != variables.end()) {
        variables.erase(it);
		return true;
    }
	return false;
}

/**
 *
 * Returns the method that is on top of the stack.
 *
 * It represents the method that is currently running, the
 * method the cpu is executing.
 *
 * If null is returned, it indicates that we are executing the "loader opcodes", which were
 * injected into the main script code and are responsible for the entry to function defined in our
 * main script code
 * @return
 */
Method* Script::getActiveMethod() {
    if (functions.size() == 0) {
        return NULL;
    } else {
        return &functions[functions.size()-1];
    }
}

/**
 * Searches the current method the script is executing for the variable indicated by string varName.
 * If such a variable is not found, searches registered script variables.  If no such variable is found
 * anywhere, null is returned
 * @param varName
 * @return
 */
ScriptVariable* Script::getVariable(std::string varName) {

    //Get and handle of the current executing method
    Method* m = getActiveMethod();
    //sv points the to variable to be returned to caller
    ScriptVariable *sv = NULL;
    if (m != NULL) { //if there is a valid and active method
        sv = m->getVariable(varName); //search for the variable we are interested in
        if ( sv == NULL ) {	 //if not found, se variable to the return value of possible registered variable
            sv = getGlobalVariable(varName);
        }
    } else {
        //Not in scope so search in global scope
        sv = getGlobalVariable(varName);
    }
    return sv;
}
/**
 * Seraches variable is GLOBAL scope.
 * @param varName
 * @return
 */
ScriptVariable* Script::getGlobalVariable(std::string varName) {
    //------- Search in global scope:
	std::map<std::string, ScriptVariable>::iterator it;
    ScriptVariable *sv = NULL;
    it = variables.find(varName);
    if (it != variables.end()) {
        sv = &it->second; //return the address of the ScriptVariable
    }
    return sv;
}

/**
 * Functions to place the entire code from script into calling object
 * @param script
 * @return return amount of code injected
 */
int Script::injectScript(Script* script) {
    for (int i=0; i<script->getSize(); i++) {
        code.push_back(script->code[i]);
    }
    return script->getSize();
}

bool Script::isSystemCall(std::string object, std::string functionName, Instruction& _xcode) {
    
    //Console print:
    if (functionName == "rep" || functionName == "print") {
        StackData sd = Stack::pop();
		ScriptConsole::print(&sd, this->script_debug);
        return true;
    }
    
    //Handle objects
    if (object != "NULL" && object != "null") {
        /**
         * Here, we find the variable denoted by 'object', then depending on the value of funcName depends
         * on the variables behavior
         */
        ScriptVariable* sv = getVariable(object);
        if (sv != NULL) {
            //return the length of a string
            if (functionName == "length") {
				StackData thelen = ScriptConsole::length(&sv->getValue());
				Stack::push(thelen);
				if (_xcode.getPointer() > 0) {
					Stack::setTopPointer(_xcode.getPointer());
				}
            }
			//return the type of a string
			if (functionName == "type") {
				StackData sdtype = ScriptConsole::type(&sv->getValue());
				Stack::push(sdtype);
				if (_xcode.getPointer() > 0) {
					Stack::setTopPointer(_xcode.getPointer());
				}
			}
            //return substring of a string
            //definition of substring: object.substring(index, numberOfCharacters)
            if (functionName == "substr") {
                if (sv->getValue().isString()) {
                    Stack::render();
					std::string value = sv->getValue().getString();
                    StackData sb = Stack::pop();	//second argument first
                    StackData sa = Stack::pop();	//first argument
                    int a = (int)sa.getNumber(true);
                    int b = (int)sb.getNumber(true);
					std::string sub = value.substr(a,b);
					Stack::push(sub);
					if (_xcode.getPointer() > 0) {
						Stack::setTopPointer(_xcode.getPointer());
					}
                }
            }

            return true;
        } else {
            ScriptError::msg("Unable to find object " + object + " for system call " + functionName);
            return false;
        }
    }
    return false;
}

/** Validate if an extension is supported or not 
 * Extension type is set in Lang
 * 
 * @param filename
 * @return boolean
 */
bool Script::validateExtension(std::wstring extension) {
	std::string to_str(extension.begin(), extension.end());
    if(find(Lang::extensionLib.begin(), Lang::extensionLib.end(), to_str) != Lang::extensionLib.end()) {
        return true;
    } else {
        ScriptError::msg("script extension \"" + to_str + "\" does not match OpenWebQuery scripts");
    }
    return false;
}

int  Script::mergeLinesAndCompile(Source *source, Parser *parser, int linenum, bool debug) {
    //Clean
    source->cleanLine();
    //Push to line stack:
    source->pushLine(linenum);
    //Debugger -> expose the render source of lines and CODE:
    if (debug && OWQ_DEBUG_LEVEL > 0 && OWQ_DEBUG_EXPOSE_COMPILER_PARSE) { source->renderSource(); }
    //Compile stuff (line of code):
    return  parser->compile(this, source->getLines(), debug);
}

std::string errors[] = {
    " ", 
    "1 script object is null",
    "2 recursive call max out script contains error",
    "3 syntax error for function definition",
    "4 if - statement syntax error",
    "5 while - statement syntax error",
    "6 else - statement syntax error",
	"7 definition - expected definition of valriable name",
	"8 misuse of Braces",
	"9 declaration variable should be followed by an assignment delimiter or by end of statement",
	"10 found two commas in variable declaration",
	"11 declaraion expression cannot contain keywords",
	"12 break statement can't use keywords",
	"13 Function declaration is expecting argument brackets followed by brace open char.",
	"14 Braces are not allowed in a argument of functions - missing a bracket close?",
	"15 Keyword sre not allowed in as function arguments - missing a bracket close?",
	"16 Braces should be use after function argument brackets.",
	"17 Unexpected bracket close - missing a bracket open char?",
	"17 Function declaratin is missing a function name.",
};

/** Loads and precompiles a script:
 * 
 * @param string filename
 * @param boolen debug
 * @return 
 * 
 */
bool Script::loadFile(fs::wpath filename) {
    return loadFile(filename, this->script_debug);
}       
bool Script::loadFile(fs::wpath filename, bool debug) {
    
	//Set debugger flag:
	script_debug = debug;

	//Force a file extension:
    if (!validateExtension(filename.extension().wstring())) {
        return false;
    }

    //Open file:
	std::wifstream input;
	std::wstring wstring_filename = filename.wstring();
	std::string string_filename(wstring_filename.begin(), wstring_filename.end());
    wchar_t cbuffer;
    input.open(filename.wstring());
    if (!input) {
        ScriptError::msg("unable to open " + string_filename + " for loading");
        return false;
    }
    //Load pre-compiler AKA Source parser:
    Source source(
        Lang::LangStringIndicator, 
        Lang::LangStringEscape,
        Lang::LangBlockOpenChar,
        Lang::LangBlockCloseChar,
        Lang::LangOperationEnd,
        Lang::LangMacroIndicator,
        Lang::LangMacroSetChar,
		Lang::LangFunctionOpenArguChar,
		Lang::LangFunctionCloseArguChar,
		Lang::LangArgumentSpacer
    );
    //Load compiler AKA  Parser:
    Parser parser;
    
    //Basic flags and counters:
    int  ret = 0;        //Return code of compiler
    int  linenum = 1;    //Keep track of line that is parsed
	bool macroFlag = false;
    bool flag = false;   //Whether to try validate the line or merge several lines.

    //Expose debugger output of pre compiling:
    if (debug && OWQ_DEBUG_LEVEL > 0 && OWQ_DEBUG_EXPOSE_COMPILER_PARSE) { Lang::printHeader("Compiler script parse and tokenize"); }

    //Render lines:
    while (input.get(cbuffer)) {
        
        //Pre parse:
        if (cbuffer != L'\n') {
            flag = source.pushChar((char)cbuffer);
            if (!flag) { continue; }
        }
        
        //We have a line check if its enough for compiling:
        if (source.validateLine()) {
            //Clean merge and compile block of code:
            ret = mergeLinesAndCompile(&source, &parser, linenum, debug);
            if (debug && OWQ_DEBUG_LEVEL > 0 && OWQ_DEBUG_EXPOSE_COMPILER_PARSE) {
                Lang::printSepLine(2);
            }
            if (ret != 0) {
                ScriptError::msg("compile error at line(" + source.getLineNumbers() + ") \"" + source.getLines() + "\" : " + errors[ret]);
                return false;
            }
            //Clear vectors and allocated memory for new pre-parse
            source.clearLines();
            
        } else {
            source.cleanLine();
            source.pushLine(linenum);
        }
        if (cbuffer == L'\n') {
            linenum++;
        }
    }
    //Execute all is left:
    ret = mergeLinesAndCompile(&source, &parser, linenum, debug);
    if (ret != 0) {
        ScriptError::msg("compile error at line(" + source.getLineNumbers() + ") \"" + source.getLines() + "\" : " + errors[ret]);
        return false;
    }
    //Clear vectors and allocated memory for new pre-parse
    source.clearLines();
    
    //Finished All show macros used if debugger is requested:
    if (debug && OWQ_DEBUG_LEVEL > 0 && OWQ_DEBUG_EXPOSE_COMPILER_MACRO_USE) { 
        Lang::printHeader("Macros and usage records");
        source.renderMacros();
        Lang::printSepLine(2);
    }
    
    if (debug && OWQ_DEBUG_LEVEL > 0 && OWQ_DEBUG_EXPOSE_COMPILED_CODE) { 
        this->render();
    }
    return true;
}

/** Destructor
 * 
 */
Script::~Script() {

}